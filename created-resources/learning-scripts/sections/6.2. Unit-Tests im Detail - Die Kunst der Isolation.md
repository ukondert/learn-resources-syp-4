## 6.2. Unit-Tests im Detail: Die Kunst der Isolation

In Kapitel 6.1 haben wir Unit-Tests als das Fundament der Testpyramide kennengelernt. Sie prüfen die kleinste, isolierte Einheit unseres Codes. Doch was bedeutet "isoliert" wirklich und wie erreichen wir das in der Praxis?

Stellen Sie sich einen Uhrmacher vor, der ein neues, komplexes Zahnrad für ein Uhrwerk entwickelt hat. Um zu prüfen, ob die Zähne des Rädchens perfekt geformt sind, wird er es nicht sofort in die fertige Uhr einbauen. Er wird es unter einem Mikroskop vermessen und in einer speziellen Vorrichtung testen. Er *isoliert* das Bauteil, um seine Funktion ohne die Einflüsse des restlichen Uhrwerks zu verifizieren. Genau das tun wir bei Unit-Tests.

### Die Herausforderung: Abhängigkeiten

Selten existiert eine Funktion oder Klasse (unsere "Unit") im luftleeren Raum. Sie hat oft **Abhängigkeiten** (Dependencies) zu anderen Teilen des Systems. In unserem Beispiel aus Kapitel 5.3 ist das der `CreateUser`-Use-Case, der ein `IUserRepository` benötigt, um zu funktionieren.

```java
// Unser Use Case, den wir testen wollen (aus Kap. 5.3)
public class CreateUser {
    // Die Abhängigkeit zu einem Repository
    private final IUserRepository userRepository;

    public CreateUser(IUserRepository userRepository) {
        this.userRepository = userRepository;
    }

    public void execute(String name, String email) {
        // Geschäftslogik: Prüfen, ob der Benutzer bereits existiert
        if (userRepository.findByName(name) != null) {
            throw new IllegalStateException("Benutzername bereits vergeben.");
        }
        User newUser = new User(name, email);
        
        // Hier wird die Abhängigkeit aufgerufen
        userRepository.save(newUser);
    }
}
```

Wenn wir nun `CreateUser` testen wollen, haben wir ein Problem: Der Test würde über das `userRepository` eine echte Datenbankverbindung aufbauen und einen echten Lese- und Schreibvorgang auslösen.
Das führt zu mehreren Problemen:
-   **Langsam:** Datenbankzugriffe sind um Größenordnungen langsamer als reine Speicheroperationen.
-   **Instabil:** Der Test kann fehlschlagen, weil die Datenbank nicht erreichbar ist, nicht weil die Logik im `UserService` falsch ist.
-   **Komplex:** Der Test benötigt eine laufende, korrekt konfigurierte Datenbank.

### Die Lösung: Mocking-Objekte

Hier kommt die Technik des **Mocking** ins Spiel. Ein **Mock-Objekt** (oder kurz "Mock") ist ein "Test-Double" – ein programmierbarer Platzhalter, der sich im Test so verhält wie die echte Abhängigkeit, aber vollständig unter unserer Kontrolle steht.

**Vorteile des Mocking:**
1.  **Echte Isolation:** Wir können die Logik des `UserService` (z.B. die Prüfung von Name und E-Mail) testen, ohne dass das `UserRepository` oder die Datenbank involviert sind.
2.  **Geschwindigkeit:** Mocks agieren nur im Arbeitsspeicher und sind blitzschnell. Tausende von Unit-Tests können in Sekunden ausgeführt werden.
3.  **Kontrolle und Determinismus:** Wir können dem Mock exakt vorschreiben, wie er sich verhalten soll. Wir können Fehlerfälle (z.B. "Was passiert, wenn die Datenbank einen Fehler wirft?") einfach und zuverlässig simulieren.

### Mehr als nur Codeabdeckung: Intelligente Teststrategien

Oft wird **Code Coverage** (Codeabdeckung) als Qualitätsmerkmal herangezogen. Ein Wert von 90% bedeutet, dass 90% der Codezeilen von Tests durchlaufen wurden. Aber Vorsicht:

> <span style="font-size: 1.5em">:warning:</span> **100% Codeabdeckung bedeutet nicht 100% fehlerfrei!** Es stellt nur sicher, dass der Code ausgeführt wurde, aber nicht, ob er sich in allen denkbaren Situationen korrekt verhält.

Wir benötigen intelligentere Strategien, um robuste Tests zu schreiben:

1.  **Happy Path & Sad Path Testing:**
    -   **Happy Path:** Der ideale, fehlerfreie Durchlauf (z.B. gültige Benutzerdaten werden übergeben, Speichern klappt).
    -   **Sad Path:** Alle denkbaren Fehler- und Sonderfälle (z.B. E-Mail ist ungültig, Datenbank ist nicht erreichbar, der zu speichernde Benutzer existiert bereits). Mocks sind perfekt, um diese "traurigen" Pfade zu erzwingen.

2.  **Boundary Value Analysis (Grenzwertanalyse):**
    -   Testet die "Ränder" von gültigen Eingabebereichen. Wenn ein Passwort zwischen 8 und 20 Zeichen lang sein muss, testen wir mit 7, 8, 20 und 21 Zeichen.

3.  **Branch/Condition Coverage (Zweig- & Bedingungsabdeckung):**
    -   Stellt sicher, dass jede Verzweigung (jeder `if`/`else`-Block, jeder `case` in einem `switch`) mindestens einmal mit einem Ergebnis `true` und einmal mit `false` durchlaufen wurde.

### Beispiel: Testen des `CreateUser`-Use-Case mit Mocking

Anknüpfend an unser API-Design aus Kapitel 5.3, wo die Schnittstelle (`IUserRepository`) der "Vertrag" ist, testen wir nun die Implementierung (`CreateUser`), die diesen Vertrag nutzt. Wir verwenden hier Java mit dem populären Mocking-Framework "**Mockito**" und dem Test-Framework "**JUnit**".

**Szenario 1: Der Happy Path**
Wir testen, ob bei gültigen Daten die `save`-Methode des Repositorys korrekt aufgerufen wird, nachdem geprüft wurde, dass der Benutzer noch nicht existiert.

```java
import static org.junit.jupiter.api.Assertions.*;
import static org.mockito.Mockito.*;

import org.junit.jupiter.api.Test;
import org.junit.jupiter.api.extension.ExtendWith;
import org.mockito.ArgumentCaptor;
import org.mockito.InjectMocks;
import org.mockito.Mock;
import org.mockito.junit.jupiter.MockitoExtension;

@ExtendWith(MockitoExtension.class)
class CreateUserTest {

    @Mock
    private IUserRepository mockRepository;

    @InjectMocks
    private CreateUser createUser;

    @Test
    void execute_WhenUserDoesNotExist_ShouldSaveNewUser() {
        // 1. Arrange (Vorbereiten)
        String name = "Max Mustermann";
        String email = "max@test.com";

        // Definiere das Verhalten des Mocks:
        // Wenn findByName mit "Max Mustermann" aufgerufen wird, gib null zurück.
        when(mockRepository.findByName(name)).thenReturn(null);

        // 2. Act (Ausführen)
        createUser.execute(name, email);

        // 3. Assert (Überprüfen)
        // Überprüfe, ob die save-Methode auf dem Mock genau 1x aufgerufen wurde.
        // Das ist der Beweis, dass unser Service seine Abhängigkeit korrekt nutzt.
        verify(mockRepository, times(1)).save(any(User.class));
        
        // Optional: Genauer prüfen, was gespeichert wurde
        ArgumentCaptor<User> userCaptor = ArgumentCaptor.forClass(User.class);
        verify(mockRepository).save(userCaptor.capture());
        
        User savedUser = userCaptor.getValue();
        assertEquals(name, savedUser.getName());
        assertEquals(email, savedUser.getEmail());
    }
}
```

**Szenario 2: Der Sad Path (Benutzer existiert bereits)**
Wir testen, ob bei einem existierenden Benutzer eine `IllegalStateException` geworfen wird.

```java
// ... (imports and class definition as above)

    @Test
    void execute_WhenUserAlreadyExists_ShouldThrowException() {
        // 1. Arrange
        String name = "Max Mustermann";
        String email = "max@test.com";
        // Simuliere, dass der Benutzer bereits existiert.
        when(mockRepository.findByName(name)).thenReturn(new User(name, email));

        // 2. Act & 3. Assert
        // Überprüfe, ob der Aufruf die erwartete Exception auslöst.
        assertThrows(IllegalStateException.class, () -> {
            createUser.execute(name, email);
        });

        // Wichtig: Sicherstellen, dass save in diesem Fall niemals aufgerufen wurde.
        verify(mockRepository, never()).save(any(User.class));
    }
```

**Szenario 3: Der Sad Path (Datenbankfehler beim Lesen)**
Wir testen, ob das System robust reagiert, wenn das Repository beim Prüfen des Benutzers einen Fehler meldet.

```java
// ... (imports and class definition as above)

    @Test
    void execute_WhenRepositoryThrowsExceptionOnFind_ShouldPropagateException() {
        // 1. Arrange
        String name = "Max Mustermann";
        String email = "max@test.com";
        
        // Konfiguriere den Mock so, dass er eine Exception wirft, wenn findByName aufgerufen wird.
        // Das simuliert einen Datenbankfehler.
        when(mockRepository.findByName(name)).thenThrow(new DatabaseException("Connection failed"));

        // 2. Act & 3. Assert
        // Wir prüfen, ob unser Use Case die Datenbank-Exception weitergibt.
        assertThrows(DatabaseException.class, () -> {
            createUser.execute(name, email);
        });
        
        // Sicherstellen, dass save auch hier niemals aufgerufen wurde.
        verify(mockRepository, never()).save(any(User.class));
    }
```

Diese Beispiele zeigen, wie wir mit Mocks die `CreateUser`-Klasse vollständig isolieren und ihre interne Logik (die Prüfung auf Duplikate) sowie ihr Verhalten bei externen Fehlern präzise und zuverlässig testen können.
