## 5.2. Systementwurf und API-Design: Vom Architektur-Blueprint zur iterativen Umsetzung

Nachdem wir uns im vorherigen Kapitel für eine grundlegende **Software-Architektur** (z.B. Clean Architecture) entschieden haben, beginnt der nächste entscheidende Schritt: der **Systementwurf**. Hier übersetzen wir den abstrakten Architektur-Blueprint in einen konkreten Bauplan für die Entwicklung. Ein zentraler Teil dieses Entwurfs ist die **Schnittstellenspezifikation**, auch bekannt als **API-Design** (Application Programming Interface).

Stellen Sie sich vor, die Software-Architektur ist die Entscheidung, ein Haus als "offenen Bungalow" zu bauen. Der Systementwurf legt nun fest, wo genau die Zimmer liegen, wie sie verbunden sind und wo sich Türen und Fenster (die Schnittstellen) befinden. Das API-Design beschreibt dann detailliert, wie diese Türen und Fenster aussehen, wie sie sich öffnen lassen und was man dahinter findet.

Dieses Kapitel dient als praktische Anleitung, wie Sie nach der Architekturwahl den Systementwurf in einem **iterativen, agilen Prozess** (z.B. in Sprints) gestalten und umsetzen können.

### 5.2.1. Die Rolle des API-Designs im agilen Prozess

In einem agilen Umfeld entwerfen wir nicht die gesamte API für das ganze Projekt im Voraus. Das wäre ein Widerspruch zu den agilen Prinzipien. Stattdessen entwerfen und implementieren wir die API **iterativ und inkrementell**, Sprint für Sprint, basierend auf den User Stories, die den höchsten Wert für den Kunden liefern.

**Der typische Ablauf pro Sprint sieht so aus:**

1.  **Sprint-Planung:** Das Team wählt User Stories aus dem Product Backlog aus (z.B. "Als Kunde möchte ich mich registrieren können").
2.  **Design-Phase (Mini-Wasserfall im Sprint):**
    *   **Analyse:** Welche Daten werden benötigt? Welche Aktionen muss der Benutzer durchführen?
    *   **API-Entwurf:** Das Team entwirft den spezifischen API-Endpunkt, der für diese User Story benötigt wird (z.B. `POST /api/users/register`).
    *   **Modell-Entwurf:** Welche Datenstrukturen (Entities, DTOs) sind in den verschiedenen Schichten der Architektur (Domain, Application, Infrastructure) notwendig?
3.  **Implementierungs-Phase:** Das Team implementiert den Endpunkt und die dazugehörige Logik gemäß der gewählten Architektur.
4.  **Test-Phase:** Der neue Endpunkt wird getestet (Unit-, Integrations-, E2E-Tests).
5.  **Sprint-Review:** Die fertige Funktionalität (inkl. des neuen API-Endpunkts) wird dem Product Owner und den Stakeholdern präsentiert.

Dieser Zyklus wiederholt sich in jedem Sprint, sodass die API organisch mit dem Produkt wächst.

### 5.2.2. API-First-Ansatz: Die Schnittstelle als Vertrag

Ein bewährter Ansatz im modernen API-Design ist **"API-First"**. Das bedeutet, die API wird entworfen und definiert, *bevor* die eigentliche Implementierung beginnt. Diese Definition dient als **Vertrag** zwischen verschiedenen Teilen des Systems (z.B. Frontend und Backend) oder sogar zwischen verschiedenen Teams.

**Vorteile des API-First-Ansatzes:**

-   **Parallelisierung der Arbeit:** Sobald der Vertrag (die API-Spezifikation) steht, kann das Frontend-Team beginnen, gegen einen "Mock" (eine Simulation) der API zu entwickeln, während das Backend-Team die Logik implementiert.
-   **Klarheit und frühes Feedback:** Die Diskussion über die API zwingt alle Beteiligten, frühzeitig über Datenmodelle und Prozesse nachzudenken. Unklarheiten werden aufgedeckt, bevor eine einzige Zeile Code geschrieben wurde.
-   **Bessere API-Qualität:** Da die API im Fokus steht, wird sie oft durchdachter, konsistenter und benutzerfreundlicher (für die Entwickler, die sie nutzen).

### 5.2.3. Praktischer Leitfaden: API-Design in einem Sprint

Nehmen wir ein konkretes Beispiel: Wir arbeiten an einer Projektmanagement-App und haben uns für die **Clean Architecture** entschieden. Im aktuellen Sprint wollen wir die folgende User Story umsetzen:

> **User Story:** "Als Projektmanager möchte ich ein neues Projekt erstellen können, damit ich Aufgaben dafür planen kann."

#### Schritt 1: Identifikation der Aktion und des Endpunkts

-   **Aktion:** Ein neues Projekt wird erstellt. In der Welt der Web-APIs entspricht das einer `POST`-Anfrage.
-   **Ressource:** Die Ressource, mit der wir arbeiten, ist ein "Projekt". Die Sammlung aller Projekte liegt üblicherweise unter einem Pfad wie `/api/projects`.
-   **Ergebnis (Endpunkt):** `POST /api/projects`

#### Schritt 2: Definition des Datenmodells (Request & Response)

Was müssen wir dem System geben, um ein Projekt zu erstellen? Was bekommen wir zurück?

-   **Request Body (Was wir hinschicken):**
    -   `name` (string, erforderlich): Der Name des neuen Projekts.
    -   `description` (string, optional): Eine kurze Beschreibung.
    -   `startDate` (date, optional): Das geplante Startdatum.
-   **Response Body (Was wir zurückbekommen):**
    -   Bei Erfolg (HTTP-Status `201 Created`): Das vollständig erstellte Projekt-Objekt, inklusive der vom System generierten ID.
        -   `id` (string/uuid): Die einzigartige ID des neuen Projekts.
        -   `name` (string): Der Name des Projekts.
        -   `description` (string): Die Beschreibung.
        -   `startDate` (date): Das Startdatum.
        -   `createdAt` (datetime): Der Zeitstempel der Erstellung.

#### Schritt 3: Entwurf der Architektur-Komponenten (Clean Architecture)

Jetzt mappen wir den API-Entwurf auf unsere gewählten Architektur-Schichten.

1.  **Domain Layer (Der Kern):**
    -   **Entity:** Wir definieren eine `Project`-Klasse. Sie enthält die reinen Geschäftsdaten und -regeln.
      ```java
      // src/domain/entities/Project.java
      public class Project {
          private String id;
          private String name;
          private String description;
          // ... Getter, Setter, Geschäftslogik ...
      }
      ```
    -   **Use Case / Port:** Wir definieren einen Anwendungsfall und die notwendigen Schnittstellen.
      ```java
      // src/domain/usecases/CreateProjectUseCase.java
      public interface CreateProjectUseCase {
          Project handle(CreateProjectCommand command);
      }

      // src/domain/ports/ProjectRepositoryPort.java
      public interface ProjectRepositoryPort {
          Project save(Project project);
      }
      ```

2.  **Infrastructure Layer (Die Adapter):**
    -   **Controller (Web Adapter):** Nimmt die HTTP-Anfrage entgegen, wandelt sie in einen Befehl um und ruft den Use Case auf.
      ```java
      // src/infrastructure/web/ProjectController.java
      @RestController
      public class ProjectController {
          private final CreateProjectUseCase createProjectUseCase;
          // ...
          @PostMapping("/api/projects")
          public ResponseEntity<ProjectDTO> createProject(@RequestBody CreateProjectDTO dto) {
              // DTO in Command umwandeln und Use Case aufrufen
              // ...
          }
      }
      ```
    -   **Repository (Persistence Adapter):** Implementiert den `ProjectRepositoryPort` und kümmert sich um das Speichern in der Datenbank.
      ```java
      // src/infrastructure/persistence/ProjectRepositoryImpl.java
      public class ProjectRepositoryImpl implements ProjectRepositoryPort {
          // ... Datenbanklogik ...
          @Override
          public Project save(Project project) {
              // ... speichert das Projekt in der DB und gibt es zurück ...
          }
      }
      ```

3.  **Application Layer (Die Verbindung):**
    -   **Use Case Implementierung:** Implementiert das `CreateProjectUseCase`-Interface und orchestriert die Logik.
      ```java
      // src/application/CreateProjectService.java
      public class CreateProjectService implements CreateProjectUseCase {
          private final ProjectRepositoryPort projectRepository;
          // ...
          @Override
          public Project handle(CreateProjectCommand command) {
              Project project = new Project(command.getName(), ...);
              return projectRepository.save(project);
          }
      }
      ```

#### Schritt 4: Dokumentation der API (Der Vertrag)

Der entworfene Endpunkt wird nun formal dokumentiert. Dies kann mit Werkzeugen wie **Swagger/OpenAPI** geschehen. Diese Spezifikation ist der "Vertrag" für alle Entwickler.

**Beispiel (OpenAPI 3.0 in YAML):**
```yaml
openapi: 3.0.0
info:
  title: Projektmanagement API
  version: 1.0.0
paths:
  /api/projects:
    post:
      summary: Erstellt ein neues Projekt
      requestBody:
        required: true
        content:
          application/json:
            schema:
              $ref: '#/components/schemas/CreateProjectRequest'
      responses:
        '201':
          description: Projekt erfolgreich erstellt
          content:
            application/json:
              schema:
                $ref: '#/components/schemas/ProjectResponse'
components:
  schemas:
    CreateProjectRequest:
      type: object
      properties:
        name:
          type: string
        description:
          type: string
    ProjectResponse:
      type: object
      properties:
        id:
          type: string
          format: uuid
        name:
          type: string
        # ... weitere Felder
```

Mit diesem detaillierten, iterativen Vorgehen stellen Sie sicher, dass Ihr Systementwurf und Ihr API-Design Hand in Hand mit den agilen Prinzipien gehen und eine robuste, wartbare und gut dokumentierte Anwendung entsteht.
