## 5.2. Schnittstellenspezifikation (API-Design)

Stellen Sie sich eine gut organisierte Restaurantküche vor. Der Koch (die Geschäftslogik) muss nicht wissen, wie der Gast am Tisch aussieht oder wie der Kellner die Bestellung aufnimmt. Er braucht nur einen klaren, standardisierten Zettel (eine Bestellung), der ihm sagt: "Einmal Wiener Schnitzel". Der Kellner ist die Schnittstelle zwischen dem Gast und der Küche. Er nimmt die Wünsche des Gastes in dessen Sprache entgegen und übersetzt sie in eine standardisierte Form, die die Küche versteht.

Genau das ist eine **API (Application Programming Interface)**: eine klar definierte Schnittstelle, die es verschiedenen Software-Komponenten ermöglicht, miteinander zu kommunizieren, ohne die internen Details der jeweils anderen Komponente kennen zu müssen.

### API-Design im agilen Prozess: Evolution statt Revolution

Die Art und Weise, wie APIs entworfen werden, unterscheidet sich fundamental zwischen traditionellen und agilen Ansätzen.

Im **traditionellen Wasserfallmodell** würde man versuchen, eine vollständige und detaillierte API-Spezifikation für das gesamte System im Voraus zu erstellen. Dieser "Big Design Upfront"-Ansatz birgt das enorme Risiko, dass man Schnittstellen für Funktionalitäten entwirft, die später anders benötigt oder gar nicht umgesetzt werden. Man schreibt quasi die komplette Speisekarte für ein 5-Sterne-Restaurant, bevor man auch nur ein einziges Gericht gekocht oder einen Gast befragt hat.

Im **agilen Vorgehen** hingegen werden APIs **evolutionär und bedarfsgetrieben** entwickelt. Eine API ist hier kein statisches Dokument, sondern ein lebendiges Produkt, das mit der Anwendung wächst. Die Entwicklung orientiert sich an folgenden Prinzipien:
- **YAGNI (You Ain’t Gonna Need It):** Es werden nur die API-Endpunkte und Datenstrukturen entworfen, die für die User Stories im aktuellen Sprint unmittelbar benötigt werden.
- **Vom Kern nach außen:** Die Entwicklung beginnt bei der Geschäftslogik. Die ersten "APIs" sind oft interne Schnittstellen (Interfaces) zwischen den Schichten, wie wir es bei der Clean Architecture gesehen haben. Eine externe Web-API ist dann nur eine von vielen möglichen "Fassaden" für diese stabile Kernlogik.
- **Iterative Verfeinerung:** Die erste Version einer API mag einfach sein. In späteren Sprints kann sie basierend auf neuem Feedback oder neuen Anforderungen erweitert werden (z.B. durch Hinzufügen von Filter- oder Sortierparametern).

Dieser Ansatz reduziert Verschwendung, ermöglicht schnelles Feedback und führt zu APIs, die genau auf die tatsächlichen Anwendungsfälle zugeschnitten sind.

### Praktisches Beispiel: Evolution einer API mit der Clean Architecture

Stellen wir uns vor, wir entwickeln eine neue Anwendung. Die erste User Story lautet: "Als neuer Benutzer möchte ich mich registrieren können, um die App nutzen zu können." Wir verfolgen die Entstehung der zugehörigen API über mehrere Sprints.

#### Sprint 1: Der Kern der Wahrheit – Geschäftslogik und interne Schnittstellen

- **Ziel:** Die Geschäftsregeln für die Benutzer-Registrierung implementieren und diese vollständig testbar machen, unabhängig von jeder externen Technologie.
- **Umsetzung:**
    1.  **Entity definieren:** Eine einfache `User`-Klasse wird erstellt.
    2.  **Interne API (Port) definieren:** Wir definieren eine Schnittstelle, die beschreibt, wie Benutzer gespeichert werden sollen, ohne uns auf eine Datenbank festzulegen. Dies ist unsere erste, rein technische API.
        ```java
        // Der Vertrag, den die Geschäftslogik zum Speichern benötigt
        public interface IUserRepository {
            void save(User user);
            User findByName(String name);
        }
        ```
    3.  **Use Case implementieren:** Die `CreateUser`-Klasse wird erstellt. Sie nutzt das `IUserRepository`-Interface, um ihre Aufgabe zu erfüllen. Sie enthält die Logik: "Prüfe, ob der Name bereits existiert, dann speichere den neuen Benutzer."
    4.  **Testen:** Wir schreiben einen **Fake-Adapter** (`InMemoryUserRepository`), der die Schnittstelle implementiert und Benutzer in einer simplen Liste im Arbeitsspeicher verwaltet. Mit diesem Fake können wir unseren Use Case zu 100% automatisiert testen.

- **Ergebnis des Sprints:** Wir haben eine funktionierende, getestete Geschäftslogik. Die wichtigste Schnittstelle – die zwischen Logik und Datenhaltung – ist definiert und im Einsatz. Es gibt noch keine externe API.

#### Sprint 2: Die erste externe Schnittstelle – Die Web-API

- **Ziel:** Die in Sprint 1 erstellte Funktionalität soll nun über eine standardisierte Web-Schnittstelle (REST-API) erreichbar gemacht werden.
- **Umsetzung:**
    1.  **Externe API spezifizieren:** Wir entwerfen den externen "Vertrag" für unsere API.
        -   **Endpunkt:** `POST /api/users`
        -   **Request Body (Anfrage):** Ein JSON-Objekt, das die Daten für den neuen Benutzer enthält.
            ```json
            { "name": "Max Mustermann", "email": "max@test.com" }
            ```
        -   **Response (Antwort):** Bei Erfolg der Statuscode `201 Created` und der neu erstellte Benutzer als JSON. Bei einem Fehler (z.B. Name schon vergeben) ein `409 Conflict`.
    2.  **Web-Adapter (Controller) implementieren:** Wir erstellen eine `UserController`-Klasse. Dieser Controller ist der "Kellner" aus unserem Anfangsbeispiel. Seine einzige Aufgabe ist es, zwischen der "Web-Welt" (HTTP) und unserem "Anwendungs-Kern" zu übersetzen:
        a. Er nimmt den HTTP-Request entgegen.
        b. Er wandelt den JSON-Body in die benötigten Daten um.
        c. Er ruft die bereits existierende, stabile `CreateUser`-Klasse aus Sprint 1 auf.
        d. Er nimmt das Ergebnis des Use Cases entgegen und wandelt es in eine passende HTTP-Antwort (z.B. Status `201` oder `409`) um.

- **Ergebnis des Sprints:** Die Funktionalität ist nun über eine saubere Web-API erreichbar. Die Kernlogik aus Sprint 1 musste dafür nicht verändert werden. Wir haben lediglich einen neuen "Zugangsweg" zu ihr geschaffen.

### Prinzipien guten API-Designs (am Beispiel REST)

Wenn wir externe APIs entwerfen, sollten wir uns an bewährte Praktiken halten, um sie verständlich und einfach nutzbar zu machen:

-   **Ressourcenorientierung (Nomen statt Verben):** APIs sollten sich um Ressourcen (Dinge) drehen, nicht um Aktionen.
    -   Gut: `GET /users/123` (Hole den Benutzer mit der ID 123)
    -   Schlecht: `GET /getUserById?id=123`
-   **HTTP-Methoden korrekt nutzen:** Die Verben stellt HTTP bereits zur Verfügung.
    -   `GET`: Daten abrufen (read-only).
    -   `POST`: Eine neue Ressource erstellen.
    -   `PUT` / `PATCH`: Eine bestehende Ressource aktualisieren.
    -   `DELETE`: Eine Ressource löschen.
-   **Sinnvolle HTTP-Statuscodes verwenden:** Geben Sie dem Client klares Feedback.
    -   `200 OK`: Alles in Ordnung.
    -   `201 Created`: Ressource wurde erfolgreich erstellt.
    -   `204 No Content`: Erfolgreich, aber keine Daten zurückzugeben (z.B. nach DELETE).
    -   `400 Bad Request`: Der Client hat ungültige Daten gesendet.
    -   `404 Not Found`: Die angeforderte Ressource existiert nicht.
    -   `500 Internal Server Error`: Ein Fehler auf dem Server ist aufgetreten.

Dieses iterative Vorgehen, geleitet von einer sauberen Architektur, ermöglicht es uns, robuste und flexible Systeme zu bauen, deren Schnittstellen mit den Anforderungen wachsen können.
